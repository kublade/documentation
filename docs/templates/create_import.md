# Import from Helm chart

This guide explains how to create a template by importing a Helm chart from a repository. The system supports both traditional Helm repositories and OCI-based repositories.

## Required Parameters[​](#required-parameters "Direct link to Required Parameters")

To import a Helm chart, you need to provide the following parameters:

* `repoUrl`: The URL of the Helm repository

  <!-- -->

  * For traditional repositories: `https://charts.example.com`
  * For OCI repositories: `oci://registry.example.com/charts`

* `chartName`: The name of the chart to import

* `repoName`: (Optional) A name for the repository (defaults to 'helm-repo')

* `namespace`: (Optional) The target namespace (defaults to 'default'). Note: In most cases, the namespace will be automatically generated by the application based on the deployment's UUID.

## Import Process[​](#import-process "Direct link to Import Process")

When importing a Helm chart, the system will:

1. Connect to the specified repository

2. Download the chart

3. Extract the values.yaml file

4. Generate the necessary Kubernetes manifests:

   <!-- -->

   * `helmrepository.yaml`: Defines the Helm repository
   * `helmrelease.yaml`: Defines the Helm release with the auto-generated namespace
   * `kustomization.yaml`: Ties everything together

## Example: Importing from a Traditional Repository[​](#example-importing-from-a-traditional-repository "Direct link to Example: Importing from a Traditional Repository")

```
# Template configuration
repoUrl: https://charts.example.com
chartName: my-application
repoName: my-repo
# namespace is optional and typically auto-generated
```

This will generate:

### helmrepository.yaml[​](#helmrepositoryyaml "Direct link to helmrepository.yaml")

```
apiVersion: source.toolkit.fluxcd.io/v1beta2
kind: HelmRepository
metadata:
  name: my-repo
spec:
  url: https://charts.example.com
  interval: 10m
```

### helmrelease.yaml[​](#helmreleaseyaml "Direct link to helmrelease.yaml")

```
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: my-application
spec:
  interval: 5m
  releaseName: my-application
  chart:
    spec:
      chart: my-application
      sourceRef:
        kind: HelmRepository
        name: my-repo
        # namespace will be automatically set to the deployment's UUID
      interval: 1m
  values:
    # Values from the chart's values.yaml
    # These will be available as $data in your template
```

### kustomization.yaml[​](#kustomizationyaml "Direct link to kustomization.yaml")

```
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
# namespace will be automatically set to the deployment's UUID
resources:
  - helmrepository.yaml
  - helmrelease.yaml
```

## Example: Importing from an OCI Repository[​](#example-importing-from-an-oci-repository "Direct link to Example: Importing from an OCI Repository")

```
# Template configuration
repoUrl: oci://registry.example.com/charts
chartName: my-application
repoName: my-oci-repo
# namespace is optional and typically auto-generated
```

This will generate similar manifests, but with OCI-specific configuration:

### helmrepository.yaml[​](#helmrepositoryyaml-1 "Direct link to helmrepository.yaml")

```
apiVersion: source.toolkit.fluxcd.io/v1beta2
kind: HelmRepository
metadata:
  name: my-oci-repo
spec:
  type: oci
  url: oci://registry.example.com/charts
  interval: 10m
```

## Template Rendering[​](#template-rendering "Direct link to Template Rendering")

For detailed information about templating your Kubernetes manifests, including variable usage, conditional logic, and port management, refer to:

* [Blade Templating Guide](/docs/templates/use_blade.md): Learn how to use the Blade templating engine for dynamic manifest generation
* [Port Management Guide](/docs/templates/use_ports.md): Understand how to manage port claims and reservations

## Best Practices[​](#best-practices "Direct link to Best Practices")

1. Always review the chart's values.yaml before importing
2. Use meaningful repository and chart names
3. Consider namespace isolation for different applications
4. Document any custom values you override
5. Test the imported chart in a staging environment first
6. Keep track of chart versions for updates
